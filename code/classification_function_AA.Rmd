---
title: "R Notebook"
output: html_notebook
---
# ML classification functions

## loop_label

Instructions
This function takes in:

iterations = number of iterations to run. Give as an integer. Eg. 2 or 3 or 4

input = dataframe of features x labels (including sample names). Will automatically drop sample names and take one label of interest at a time when running model

label_list = a vector of your label names as strings. Eg. c("group", "group_shuffle")

percent = percentage of train to test. specify as a double. Eg. 0.6.
```{r}

loop_label = function(iterations, input, label_list, percent= 0.7, upsampling = FALSE, downsampling = FALSE){
  
  #Initialize results
  
  auc_df = data.frame(row = 1:iterations)
  #cf_list = list()
  cummulative_importance = data.frame()
  
  #Label loop
  
  for(label in label_list){
    
    # Remove labels not being tested in this iteration
    
    current_data = input %>%
      select(-label_list[label_list != label]) %>%
      select(-sample)
    
    # Upsampling
    
    if(upsampling ==TRUE){
      print("will upsample using smote on training data")
    }
    
    # Downsampling
    
    if(downsampling ==TRUE){
      print("will downsample on training data")
    }
    
    #Model loop
    
    results = loop_model(iterations, current_data, label, percent, upsampling, downsampling)
    
    # Print cummulative confusion matrix
    
    print(label) # eventually want to make this a result that is stored instead of printing like this.
    print(results[[1]])
    
    # Store AUC values in cummulative dataframe
    
    auc_df = auc_df %>%
      cbind(results[[2]])
    
    # After this Ben has functions to plot importances- I will need to code.
    
    # After this Ben plots AUCs, I will plot outside the function
    
    # Returning results from all labels
    
    cummulative_importance = cummulative_importance %>%
      rbind(results[[3]])
  }
  
  final = list(cummulative_importance, auc_df)
  
  return(final)
}
```

## testing loop_label

```{r}
# label_list = c("group", "group_shuffle")
# 
# results = loop_label(iterations = 2, input, label_list, percent = 0.7)
```


##loop_model

Instructions

This function takes in:

iterations = number of iterations to run. Give as an integer. Eg. 2 or 3 or 4

current_data = dataframe of features x labels (only label of interest and no sample names).

label = name of your label column. specified as a string. Eg. "group"

percent = percentage of train to test. specify as a double. Eg. 0.6.

```{r}

loop_model = function(iterations, current_data, label, percent= 0.7, upsampling = FALSE, downsampling = FALSE){
  
  # Initialize results
    
    input_cf = 0
    auc_list = c()
    importance_df = data.frame()

  for (i in 1:iterations) {
    
    # Data splitting
    train_ind = caret::createDataPartition((current_data %>%
                                              pull(label)), #split based on labe column
                                     p = percent,
                                     list = FALSE,
                                     times = 1)
    train = current_data[train_ind,]
    test = current_data[-train_ind,]
    
    #Upsampling
   
    if(upsampling == TRUE){
      train[[label]] = as.factor(train[[label]])
      train = train %>%
        as.data.frame()
      
      formula_smote = label %>%
      paste0("~.") %>%
      as.formula()
      
      train = DMwR::SMOTE(formula_smote, data  = train)
    }
    
    # Downsampling
    
    if(downsampling == TRUE){
      train = downSample(x = train,
                         y = train[[label]])
      train = train %>%
        select(-Class)
    }
    
    # Training model
    
    formula = label %>%
      paste0("~.") %>%
      as.formula()
    
    fit_control = caret::trainControl(method = "CV", # 5-fold cross validation
                                 number = 5,
                                 summaryFunction = prSummary,
                                 classProbs = T)
    
    model = caret::train(formula, #using formula specified 
              data = train,
                  method = "rf",
                  trControl = fit_control,
                  verbose = FALSE, 
                  metric = "AUC")
    
    # Model predictions
    
    predictions = predict(model, newdata = test, type= "prob")
    
    pred_labels = predict(model, newdata = test)%>%
      as.factor ()
    
    predictions$obs = test %>%
      pull(label) %>%
      as.factor() 
    
    # Confusion matrix
    
    cf = caret::confusionMatrix(data = pred_labels, reference =as.factor(predictions$obs), mode = "prec_recall")
    
    input_cf = input_cf + cf$table
    
    # Evaluate model
    
    eval = MLeval::evalm(predictions, showplots = FALSE, silent = TRUE)
    
    auc_list = append(auc_list, eval$stdres$`Group1`[13,1])
    
    #Extract feature importance
    
    feature_importance = caret::varImp(model$finalModel) %>% # Ben calls this importances instead of final model but the rankings are exactly the same, only number value scale is different.
      arrange(desc(Overall)) %>%
      as.matrix() %>%
      t()
    
    importance_df = rbind(importance_df, feature_importance)
    
  }
  
  #Naming all results with appropriate label
  
  input_cf = list(label, input_cf)
  
  auc_list = auc_list %>% as.data.frame()
  colnames(auc_list) = label
  
  importance_df = importance_df %>%
    mutate(variable = label)
  
  #Join all the result elements together in a list: cf, auc vector, importance df
  
  results_list = list(input_cf, auc_list, importance_df)
  
  return(results_list) 
}
```

## testing loop_model

```{r}
# label = "group"
# input_cf = 0
# auc_list = c()
# importance_df = data.frame()
# percent = 0.7
# iterations = 2
# 
# current_data = input %>%
# select(-c(sample, group_shuffle))
# 
# results = loop_model(iterations = 2, current_data, label, percent, input_cf, auc_list, importance_df)
```

# Visualization

```{r}
#input = dataframe of features x labels (including sample names)
# List of foods in order of model importance

plot_food_direction = function(food_ranking, data, variable) {
 
  for(food in food_ranking) {
  plot = data %>%
  select(variable, food) %>%
  ggplot()+
  geom_boxplot(aes_string(x= variable, y= food))+
  theme_classic() 
  
  print (plot)
  } 
  
}
```

